- [Redis概述](#Redis概述)
- [Redis在Java Web中的应用](#Redis在Java-Web中的应用)
    * [缓存](#存储缓存用的数据)
    * [高速读写场合](#需要高速读写的场合使用它快速读写)
- [redis知识点](#redis知识点)
    * [用redis的理由](#用redis的理由)
    * [redis数据结构](#redis数据结构)
    * [redis中的对象类型](#redis中的对象类型)
    * [redis的作用](#redis的作用)
    * [redis使用过程中需要注意的](#redis使用过程中需要注意的)
    * [redis数据持久化](#redis数据持久化)
    * [redis集群访问](#redis集群访问)
    * [redis的单线程](#redis的单线程)
    * [不适合用redis的情况](#不适合用redis的情况)
- [redis原理](#redis原理)

---
* refs:
    * > https://zhuanlan.zhihu.com/p/37982685
    * > https://www.cnblogs.com/Jtianlin/p/10259062.html
---

### Redis概述
* 在我们日常的Java Web开发中，无不都是使用数据库来进行数据的存储，由于一般的系统任务中通常不会存在高并发的情况，所以这样看起来并没有什么问题，可是一旦涉及大数据量的需求，比如一些商品抢购的情景，或者是主页访问量瞬间较大的时候，单一使用数据库来保存数据的系统会因为面向磁盘，磁盘读/写速度比较慢的问题而存在严重的性能弊端，一瞬间成千上万的请求到来，需要系统在极短的时间内完成成千上万次的读/写操作，这个时候往往不是数据库能够承受的，极其容易造成数据库系统瘫痪，最终导致服务宕机的严重生产问题。
* 为了克服上述的问题，Java Web项目通常会引入NoSQL技术，这是一种基于内存的数据库，并且提供一定的持久化功能。
* Redis和MongoDB是当前使用最广泛的NoSQL，而就Redis技术而言，它的性能十分优越，可以支持每秒十几万此的读/写操作，其性能远超数据库，并且还支持集群、分布式、主从同步等配置，原则上可以无限扩展，让更多的数据存储在内存中，更让人欣慰的是它还支持一定的事务能力，这保证了高并发的场景下数据的安全和一致性。

### Redis在Java Web中的应用
#### 缓存
* 在日常对数据库的访问中，读操作的次数远超写操作，比例大概在`1:9`到`3:7`，所以需要读的可能性是比写的可能大得多的。当我们使用SQL语句去数据库进行读写操作时，数据库就会去磁盘把对应的数据索引取回来，这是一个相对较慢的过程。
* 如果我们把数据放在Redis中，也就是直接放在内存之中，让服务端直接去读取内存中的数据，那么这样速度明显就会快上不少，并且会极大减小数据库的压力，但是使用内存进行数据存储开销也是比较大的，限于成本的原因，一般我们只是使用Redis存储一些常用和主要的数据，比如用户登录的信息等。
* 一般而言在使用Redis进行存储的时候，我们需要从以下几个方面来考虑:
    * 业务数据常用吗？命中率如何？如果命中率很低，就没有必要写入缓存；
    * 该业务数据是读操作多，还是写操作多？如果写操作多，频繁需要写入数据库，也没有必要使用缓存；
    * 业务数据大小如何？如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；
* 如果有必要使用缓存，使用Redis作为缓存的读取逻辑:
    * 当第一次读取数据的时候，读取Redis的数据就会失败，此时就会触发程序读取数据库，把数据读取出来，并且写入Redis中；
    * 当第二次以及以后需要读取数据时，就会直接读取Redis，读到数据后就结束了流程，这样速度就大大提高了。
* 使用Redis来处理日常中需要经常读取的数据，速度提升是显而易见的，同时也降低了对数据库的依赖，使得数据库的压力大大减少。
* 从流程可以看出，更新或者写入的操作，需要多个Redis的操作，如果业务数据写次数远大于读次数那么就没有必要使用Redis。

#### 高速读写场合
* 在如今的互联网中，越来越多的存在高并发的情况，比如天猫双11、抢红包、抢演唱会门票等，这些场合都是在某一个瞬间或者是某一个短暂的时刻有成千上万的请求到达服务器，如果单纯的使用数据库来进行处理，就算不崩，也会很慢的，轻则造成用户体验极差用户量流失，重则数据库瘫痪，服务宕机。
* 所以我们需要使用Redis来应对这样的高并发需求的场合:
    * 当一个请求到达服务器时，只是把业务数据在Redis上进行读写，而没有对数据库进行任何的操作，这样就能大大提高读写的速度，从而满足高速响应的需求；
    * 但是这些缓存的数据仍然需要持久化，也就是存入数据库之中，所以在一个请求操作完Redis的读写之后，会去判断该高速读写的业务是否结束，这个判断通常会在秒杀商品为0，红包金额为0时成立，如果不成立，则不会操作数据库；如果成立，则触发事件将Redis的缓存的数据以批量的形式一次性写入数据库，从而完成持久化的工作。

### redis知识点
#### 用redis的理由
* 速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件；
    * 单线程仅仅是说在网络请求这一模块上用一个线程处理客户端的请求，像持久化它就会重开一个线程/进程去进行处理
* 丰富的数据类型，Redis有8种数据类型，当然常用的主要是`String`、`Hash`、`List`、`Set`、`SortSet`这5种类型，他们都是基于键值的方式组织数据。每一种数据类型提供了非常丰富的操作命令，可以满足绝大部分需求，如果有特殊需求还能自己通过lua脚本自己创建新的命令(具备原子性)。
* 除了提供的丰富的数据类型，Redis还提供了像`慢查询分析`、`性能测试`、`Pipeline`、`事务`、`Lua自定义命令`、`Bitmaps`、`HyperLogLog`、`发布/订阅`、`Geo`等个性化功能。
* 支持事务、持久化、主从复制让高可用、分布式成为可能。

#### redis数据结构
* 简单动态字符串
* 链表: 
    * 链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。
    * 链表被广泛用于redis的各种功能，比如`列表键`、`发布与订阅`、`慢查询`、`监视器`等
* 字典:
    * 又称为符号表，关联数组或映射，是一种用于保存键值对的抽象数据结构。
    * redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。
    * 字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。
* 跳跃表:
    * 跳跃表是以各种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。
    * redis只有两个地方用到跳跃表:
        * 一个是实现有序集合键
        * 另一个是在集群节点中用作内部数据结构。
* 整数集合
    * 整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。
    * 整数集合可以保存的类型为: int16_t，int32_t，int64_t 的整数值，并且保证集合中不会出现重复元素。
    * 当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，
    * 然后才能将新元素添加到整数集合里面。整数集合只支持升级操作，不支持降级操作。

#### redis中的对象类型
* Redis并没有使用之前介绍的数据结构来实现键值对数据库，而是基于那些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型对象。
* 每种类型的对象至少都有两种或者以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。
* Redis会共享值为0到9999的字符串对象。Redis只对包含整数值的字符串对象进行共享。对象会记录自己的最后一个被访问的时间，这个时间可以用于计算对象的空转时间，用以判断回收内存。
* Redis中的每个对象都由一个`redisObject`结构表示，该结构中和保存数据相关的三个属性分别是`type`属性，`encoding`属性和`ptr(指针)`属性。
    * String(字符串): 字符串的编码可以是int，raw或者embstr(短字符串)。在条件满足的情况下，int和embstr会被转换成raw编码的字符串对象。
    * List(列表): 列表对象的编码可以是ziplist(压缩列表)或者linkedlist(双端列表)
    * Hash(哈希): 哈希对象的编码可以是ziplist(压缩列表)或者hashtable(字典)
    * Set(集合): 集合对象的编码可以是intset(整数集合)或者hashtable(字典)
    * ZSet(有序集合): 有序集合对象，编码可以是ziplist(压缩列表)或者skiplist(字典+跳跃表，使用两种结构更高效)
    * Bitmaps(位图): BitMap 就是通过一个 bit 位来表示某个元素对应的值或者状态, 其中的 key 就是对应元素本身，实际上底层也是通过对字符串的操作来实现。
        * bitmaps一般的使用场景:
            * 各种实时分析.
            * 存储与对象ID关联的节省空间并且高性能的布尔信息.
    * HyperLog
    * Geo(地理位置信息)

#### redis的作用
* 缓存
    * 数据和缓存的操作时序，结论是清楚的：先淘汰缓存，再写数据库，再淘汰缓存。
        * 原因:
            * 假设先写数据库，再淘汰缓存：第一步写数据库操作成功，第二步淘汰缓存失败，则会出现DB中是新数据，Cache中是旧数据，数据不一致。
            * 假设先淘汰缓存，再写数据库：第一步淘汰缓存成功，第二步写数据库失败，则只会引发一次Cache miss。
            * 第二次淘汰缓存的目的是避免写数据库期间，有新的缓存添加。当然，如果这种情况下，二次淘汰缓存失败，仍然有可能有脏数据
        * 更新缓存VS淘汰缓存
            * 淘汰缓存，避免两个并发写操作，导致脏数据
            * 并且淘汰缓存操作简单，并且带来的副作用只是增加了一次cache miss，建议作为通用的处理方式。
* 分布式锁
    * 建议通过引入Redisson相关jar包使用。
    * 加锁注意: 线程唯一标记(自己加的锁，只能自己解，只能解自己加的锁)，过期时间(避免系统崩溃后形成死锁)，没有已存在的锁才能加锁成功
    * 解锁注意: 只能解自己的锁，不能直接使用del，避免锁过期删除了别人的锁(锁过期导致)。所以一般使用lua脚本执行，保证原子性。
* 排行榜
    * 获取排名和分数 通过zscore指令获取指定元素的权重，通过zrank指令获取指定元素的正向排名，通过zrevrank指令获取指定元素的反向排名。正向是由小到大，负向是由大到小。
    * 根据排名范围获取元素列表 通过zrange指令指定排名范围参数获取对应的元素列表，携带withscores参数可以一并获取元素的权重。通过zrevrange指令按负向排名获取元素列表。正向是由小到大，负向是由大到小。
    * 根据score范围获取列表 通过zrangebyscore指令指定score范围获取对应的元素列表。通过zrevrangebyscore指令获取倒排元素列表。正向是由小到大，负向是由大到小。参数-inf表示负无穷，+inf表示正无穷。
* 计数器/限速器
    * 字符串可以作为计数器: INCRBY(整数加法)，DECRBY(整数减法)
    * hash结构也可以当成计数器来使用，对于内部的每一个key都可以作为独立的计数器。如果value值不是整数，调用hincrby指令会出错。
    * 利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的
    * 使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；
* 好友关系
    * 利用集合(Set)的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；
* 简单的订阅消息(订阅发布/阻塞队列)
    * 利用List来实现一个队列机制，比如:到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；
* 用户是否登录过
    * Bitmaps的最大优点就是存储信息时可以节省大量的空间。例如在一个系统中，不同的用户被一个增长的用户ID表示。
    * `40亿(2^32=4*1024*1024*1024≈40亿)`用户只需要512M内存就能记住某种信息
* Session共享
    * 默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。
* 分布式全局唯一id
    * 可以每次id加1，获取一个；也可以一次加100，批量获取

#### redis使用过程中需要注意的
* 缓存需要注意什么
    * 读多写少，更新频率低的时候才使用缓存
    * 先淘汰缓存，再写数据库，再淘汰缓存
* 分布式锁需要注意什么
    * 只能自己解锁，只能解自己的锁，加过期时间避免死锁，解锁时保持原子性
    * 单节点无法保证高可用；主从架构可能从库复制延迟，引起锁重复(主库挂了，从库没有复制到新锁)；集群同样可能导致锁重复。
* 怎样避免雪崩
    * 所谓“缓存雪崩“，是指缓存的机器挂了，或者数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。
    * 这种问题的解决策略，一般有以下2个方面： 
        * 提高缓存的HA。比如缓存的主从复制。 
        * 对DB的访问实行限流、降级。
        * 缓存过期时间。以redis为例，将过期设置放到1数据库，真实数据放到0数据库，key值相同，假设都为key1。应用程序首先判断1库这条数据是否失效，当1库标记数据库数据失效或过期，在1库中设置新的过期时间。然后从数据库取数据更新0数据库中的数据。如果判断1数据库未失效，从0数据库取出数据返回。
        * 启动缓存时，进行数据预热。或者 缓存重启时，有之前的持久化文件预热。 
* 避免缓存穿透
    * 所谓“缓存穿透“，就是指某个key，先查cache没查到，再查db也没有查到。
    * 这种key的存在，会导致cache一直没办法命中，压力一直打在db上面。如果访问很高频，可能会压垮DB。
    * 解决办法其实也很简单：当查询DB没查到时，往缓存中写入一个空值(缺省值)，这样第2次再查，就不会打到DB上了。

#### redis数据持久化
Redis有两种持久化的方式: 快照(RDB文件)和追加式文件(AOF文件)：
    * RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。
    * AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。
    * Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。
    * 两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。

#### redis集群访问
* Redis集群通过分区(partition)来提供一定程度的可用性(availability):
    * 即使集群中有一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求。
    * Redis集群提供了以下两个好处:
        * 将数据自动切分(split)到多个节点的能力。
        * 当集群中的一部分节点失效或者无法进行通讯时，仍然可以继续处理命令请求的能力。
* Redis集群使用数据分片(sharding)而非一致性哈希(consistency hashing)来实现:
    * 一个Redis集群包含16384个哈希槽(hash slot)，数据库中的每个键都属于这16384个哈希槽的其中一个，集群使用公式`CRC16(key)%16384`来计算键key属于哪个槽，其中 `CRC16(key)`语句用于计算键key的`CRC16`校验和。
    * 集群中的每个节点负责处理一部分哈希槽。举个例子，一个集群可以有三个哈希槽，其中:
        * 节点A负责处理0号至5500号哈希槽。
        * 节点B负责处理5501号至11000号哈希槽。
        * 节点C负责处理11001号至16384号哈希槽。
    * 主从复制模型: 
        * 我们为主节点B添加了从节点B1，那么当主节点B下线的时候，集群就会将B1设置为新的主节点，并让它代替下线的主节点B，继续处理5501号至11000号的哈希槽，这样集群就不会因为主节点B的下线而无法正常运作了。不过如果节点B和B1都下线的话，Redis集群还是会停止运作。
    * 开启集群需要手动执行命令
    * 主节点挂了，从节点会变成主节点。当原主节点重启后，原主节点会成为新主节点的从节点。
    * 增加和删除节点，都需要手动移动数据。

#### redis的单线程
* 线程安全是指redis是单线程，将变量拷贝到线程内存中。因为是单线程，所以这个变量是公用的。redis实际上是采用了线程封闭的观念，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁。
* Redis对于I/O多路复用模块的设计非常简洁，通过宏保证了I/O多路复用模块在不同平台上都有着优异的性能，将不同的I/O多路复用函数封装成相同的API提供给上层使用。整个模块使Redis能以单进程运行的同时服务成千上万个文件描述符，避免了由于多进程应用的引入导致代码实现复杂度的提升，减少了出错的可能性。

#### 过期策略
* 定期删除: Redis默认会每秒进行十次过期扫描(100ms一次)，过期扫描不会遍历过期字典中所有的key，而是采用了一种简单的贪心策略。从过期字典中随机20个key；删除这20个key中已经过期的key；如果过期的key比率超过1/4，那就重复步骤1；
* 惰性删除: 所谓惰性策略就是在客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西。

#### 内存淘汰策略
* Redis将数据放到内存中，内存是有限的，比如redis就只能用10个G，你要是往里面写了20个G的数据，会咋办？当然会干掉10个G的数据，然后就保留10个G的数据了。那干掉哪些数据？保留哪些数据？当然是干掉不常用的数据，保留常用的数据了
* Redis提供的内存淘汰策略有如下几种：
    * `noeviction`不会继续服务写请求(DEL请求可以继续服务)，读请求可以继续进行。这样可以保证不会丢失数据，但是会让线上的业务不能持续进行。这是默认的淘汰策略。
    * `volatile-lru`尝试淘汰设置了过期时间的key，最少使用的key优先被淘汰。没有设置过期时间的key不会被淘汰，这样可以保证需要持久化的数据不会突然丢失。(这个是使用最多的)
    * `volatile-ttl`跟上面一样，除了淘汰的策略不是LRU，而是key的剩余寿命ttl的值，ttl越小越优先被淘汰。
    * `volatile-random`跟上面一样，不过淘汰的key是过期key集合中随机的key。
    * `allkeys-lru`区别于`volatile-lru`，这个策略要淘汰的key对象是全体的key集合，而不只是过期的key集合。这意味着没有设置过期时间的key也会被淘汰。
    * `allkeys-random`跟上面一样，不过淘汰的策略是随机的key。`allkeys-random`跟上面一样，不过淘汰的策略是随机的key。

#### 不适合用redis的情况
* 更新频率太快
* 数据量太大

### redis原理

