- [Java概述](#Java概述)
    * [JVM](#JVM)
        * [Java内存区域与内存溢出异常](#Java内存区域与内存溢出异常)
            * [程序计数器](#程序计数器)
            * [虚拟机栈](#虚拟机栈)
            * [本地方法栈](#本地方法栈)
            * [堆](#堆)
            * [方法区](#方法区)
            * [运行时常量池](#运行时常量池)
            * [直接内存](#直接内存)
        * [HotSpot虚拟机对象探秘](#HotSpot虚拟机对象探秘)
            * [对象的创建](#对象的创建)
            * [对象的内存布局](#对象的内存布局)
        * [垃圾回收器与内存分配策略](#垃圾回收器与内存分配策略)
            * [判断对象是否已死](#判断对象是否已死)
                * [引用计数法](#引用计数法)
                * [可达性分析法](#可达性分析法)
                * [再谈引用](#再谈引用)
                * [生存还是死亡](#生存还是死亡)
                * [回收方法区](#回收方法区)
            * [垃圾回收算法](#垃圾回收算法)
                * [标记-清除算法](#标记-清除算法)
                * [复制算法](#复制算法)
                * [标记-整理算法](#标记-整理算法)
                * [分代回收](#分代回收)
            * [垃圾回收器](#垃圾回收器)
                * [Serial收集器](#Serial收集器)
                * [ParNew收集器](#ParNew收集器)
                * [Parallel Scavenge收集器](#Parallel-Scavenge收集器)
                * [Serial Old收集器](#Serial-Old收集器)
                * [Parallel Old收集器](#Parallel-Old收集器)
                * [CMS收集器](#CMS收集器)
                * [G1收集器](#G1收集器)
            * [内存分配与回收策略](#内存分配与回收策略)
                * [对象优先在Eden分配](#对象优先在Eden分配)
        * [Java内存模型与线程](#Java内存模型与线程)
            * [Java内存模型](#Java内存模型)
                * [主内存和工作内存之间的交互](#主内存和工作内存之间的交互)
                * [对于volatile型变量的特殊规则](#对于volatile型变量的特殊规则)
                * [对于long和double型变量的特殊规则](#对于long和double型变量的特殊规则)
                * [原子性、可见性与有序性](#原子性-可见性与有序性)
                * [先行发生原则](#先行发生原则)
            * [Java与线程](#Java与线程)
                * [线程的实现](#线程的实现)
                * [Java线程调度](#Java线程调度)
                * [线程状态转换](#线程状态转换)
        * [线程安全与锁优化](#线程安全与锁优化)
        * [类文件结构](#类文件结构)
        * [虚拟机类加载机制](#虚拟机类加载机制)
            * [类加载时机](#类加载时机)
            * [类的加载过程](#类的加载过程)
                * [加载](#加载)
                * [验证](#验证)
                * [准备](#准备)
                * [解析](#解析)
                * [初始化](#初始化)
            * [类加载器](#类加载器)
                * [双亲委派模型](#双亲委派模型)
                * [破坏双亲委派模型](#破坏双亲委派模型)
    * [跨平台性](#跨平台性)
    * [Java和C++的区别](#Java和C++的区别)
    * [OracleJDK和OpenJDK的对比](#OracleJDK和OpenJDK的对比)
- [基础语法](#基础语法)
    * [访问修饰符](#访问修饰符)
        * [private](#private)
        * [default](#private)
        * [public](#private)
        * [protected](#private)
    * [关键字](#关键字)
        * [final有什么用](#final有什么用)
        * [this关键字](#this关键字的用法)
        * [super关键字](#super关键字的用法)
        * [this与super的一些事](#this与super的一些事)
        * [static关键字](#static关键字)
        * [new关键字](#new关键字)
    * [面向对象](#面向对象)
        * [三大特性](#三大特性)
        * [五大原则](#五大原则)
    * [类与接口](#类与接口)
        * [抽象类和接口的对比](#抽象类和接口的对比)
        * [普通类和抽象类](#普通类和抽象类)
    * [变量与方法](#变量与方法)
    * [构造方法](#构造方法)
    * [内部类](#内部类)
        * [内部类基础](#内部类基础)
            * [成员内部类](#成员内部类)
            * [局部内部类](#局部内部类)
            * [匿名内部类](#匿名内部类)
            * [静态内部类](#静态内部类)
        * [深入理解内部类](#深入理解内部类)
    * [重写与重载](#重写与重载)
    * [对象相等判断](#对象相等判断)
        * [==和equals](#==和equals)
        * [hashCode和equals](#hashCode和equals)
        
---
* refs:
    * > https://www.cnblogs.com/dolphin0520/p/3811445.html
    * > https://thinkwon.blog.csdn.net/article/details/104390612
    * > https://zhuanlan.zhihu.com/p/25539690
    * > https://juejin.im/post/5aca2c366fb9a028c97a5609
    * > https://windysha.github.io/2018/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8BJava%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%88-class%EF%BC%89%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/
    * > https://www.cnblogs.com/dolphin0520/p/10651845.html
    * > https://zhuanlan.zhihu.com/p/45445817
    * > https://segmentfault.com/a/1190000021898422
    * > https://www.cnblogs.com/dolphin0520/p/3811445.html
---

## Java概述
### JVM
#### Java内存区域与内存溢出异常
##### 程序计数器
* 如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器的值则为(`Undefined`)。
    * 内存空间小，线程私有。
    * 字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成。
* 此内存区域是唯一一个在Java虚拟机规范中没有规定任何`OutOfMemoryError`情况的区域。

##### 虚拟机栈
* 局部变量表: 存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用reference类型)和returnAddress类型(指向了一条字节码指令的地址)。
    * 线程私有，生命周期和线程一致。
    * 描述的是Java方法执行的内存模型: 每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
    * 每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。
* 内存溢出异常
    * `StackOverflowError`: 线程请求的栈深度大于虚拟机所允许的深度。
    * `OutOfMemoryError`: 如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。

##### 本地方法栈
* 区别于虚拟机栈的是，虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的Native方法服务。也会有`StackOverflowError`和`OutOfMemoryError`异常。

##### 堆
* 主要是存放对象实例和数组。
    * 对于绝大多数应用来说，这块区域是JVM所管理的内存中最大的一块。
    * 线程共享。
    * 内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。
    * 可以位于物理上不连续的空间，但是逻辑上要连续。
* 分区:
    * 新生类
        * `Eden`
        * `Survivor(From)`
        * `Survivor(To)`
    * 老年类
* 内存溢出异常
    * `OutOfMemoryError`: 如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。

##### 方法区
* 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
    * 属于共享内存区域。

##### 运行时常量池
* 属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String的`intern()`)都可以将常量放入池中。
* 内存溢出异常
    * 内存有限，无法申请时抛出`OutOfMemoryError`。

##### 直接内存
* 非虚拟机运行时数据区的部分
    * 在JDK1.4中新加入NIO类，引入了一种基于通道(Channel)和缓存(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在堆中的`DirectByteBuffer`对象作为这块内存的引用进行操作。
    * 可以避免在堆和Native堆中来回的数据耗时操作。
* 内存溢出异常
    * `OutOfMemoryError`: 会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。

#### HotSpot虚拟机对象探秘
##### 对象的创建
1. 遇到`new`指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，执行相应的类加载。
2. 类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域(`指针碰撞-内存规整`或`空闲列表-内存交错`的分配方式)。
    * 前面讲的每个线程在堆中都会有私有的分配缓冲区(TLAB)，这样可以很大程度避免在并发情况下频繁创建对象造成的线程不安全。
3. 内存空间分配完成后会初始化为`0`(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息存入对象头。
4. 执行`new`指令后执行`init`方法后才算一份真正可用的对象创建完成。

##### 对象的内存布局
* 在HotSpot虚拟机中，分为3块区域: 对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)
    * 对象头(Header): 包含两部分:
        * 第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，32位虚拟机占32bit，64位虚拟机占64bit。官方称为`Mark Word`。
        * 第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是Java数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过Java对象元数据确定大小，而数组对象不可以。
    * 实例数据(Instance Data): 程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。
    * 对齐填充(Padding): 不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。
    
##### 对象的访问定位
* 使用对象时，通过栈上的reference数据来操作堆上的具体对象。
* 通过句柄访问
    * 堆中会分配一块内存作为句柄池。reference存储的是句柄地址。
    * 句柄中存了到对象实例数据的指针和到对象类型数据的指针。
* 使用直接指针访问
    * reference中直接存储对象地址。
    * 对象实例数据中也存了一个到对象类型数据的指针。
* 比较:
    * 使用句柄的最大好处是reference中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference自身不需要修改。
    * 直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。
    * 如果是对象频繁GC那么句柄方法好，如果是对象频繁访问则直接指针访问好。

#### 垃圾回收器与内存分配策略
* 程序计数器、虚拟机栈、本地方法栈3个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。
* 而堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是这部分内存。

##### 判断对象是否已死
* 在进行内存回收之前要做的事情就是判断那些对象是`死`的，哪些是`活`的。

###### 引用计数法
* 给对象添加一个引用计数器。但是难以解决循环引用问题。

###### 可达性分析法
* 通过一系列的`GC Roots`的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到`GC Roots`没有任何引用链相连的时候说明对象不可用。
* 可作为`GC Roots`的对象:
    * 虚拟机栈(栈帧中的本地变量表)中引用的对象
    * 方法区中类静态属性引用的对象
    * 方法区中常量引用的对象
    * 本地方法栈中JNI(即一般说的Native方法)引用的对象

###### 再谈引用
* 下面四种引用强度一次逐渐减弱
    * 强引用
        * 类似于`Object obj = new Object();`创建的，只要强引用在就不回收。
    * 软引用
        * `SoftReference`类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。
    * 弱引用
        * `WeakReference`类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。
    * 虚引用
        * `PhantomReference`类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

###### 生存还是死亡
* 即使在可达性分析算法中不可达的对象，这时候它们暂时出于“缓刑”阶段，一个对象的真正死亡至少要经历两次标记过程:
    * 如果对象在进行中可达性分析后发现没有与`GC Roots`相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行`finalize()`方法。
    * 当对象没有覆盖`finalize()`方法，或者`finalize()`方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
* 如果这个对象被判定为有必要执行`finalize()`方法，那么这个对象竟会放置在一个叫做`F-Queue`的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的`Finalizer`线程去执行它。这里所谓的“执行”是指虚拟机会出发这个方法，并不承诺或等待他运行结束。`finalize()`方法是对象逃脱死亡命运的最后一次机会，稍后GC将对`F-Queue`中的对象进行第二次小规模的标记，如果对象要在`finalize()`中成功拯救自己，只要重新与引用链上的任何一个对象简历关联即可。
* `finalize()`方法只会被系统自动调用一次。

###### 回收方法区
* 在堆中，尤其是在新生代中，一次垃圾回收一般可以回收`70%~95%`的空间，而永久代的垃圾收集效率远低于此。
* 永久代垃圾回收主要两部分内容: 废弃的常量和无用的类。
* 判断废弃常量: 一般是判断没有该常量的引用。
* 判断无用的类：要以下三个条件都满足
    * 该类所有的实例都已经回收，也就是堆中不存在该类的任何实例。
    * 加载该类的`ClassLoader`已经被回收。
    * 该类对应的`java.lang.Class`对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

##### 垃圾回收算法
###### 标记-清除算法
* 直接标记清除就可。
* 两个不足:
    * 效率不高
    * 空间会产生大量碎片

###### 复制算法
* 把空间分成两块，每次只对其中一块进行GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。
* 解决前一种方法的不足，但是会造成空间利用率低下。因为大多数新生代对象都不会熬过第一次 GC，所以没必要`1 : 1`划分空间。
    1. 可以分一块较大的`Eden`空间和两块较小的`Survivor`空间，每次使用`Eden`空间和其中一块`Survivor`。
    2. 当回收时，将`Eden`和`Survivor`中还存活的对象一次性复制到另一块`Survivor`上，最后清理`Eden`和`Survivor`空间。
    3. 大小比例一般是`8 : 1 : 1`，每次浪费`10%`的`Survivor`空间。
    4. 但是这里有一个问题就是如果存活的大于`10%`怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。

###### 标记-整理算法
* 不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。

###### 分代回收
* 根据存活对象划分几块内存区，一般是分为新生代和老年代。然后根据各个年代的特点制定相应的回收算法。
* 新生代
    * 每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理。
* 老年代
    * 老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用`标记-清除`或者`标记-整理`算法回收。

##### 垃圾回收器
* 收集算法是内存回收的理论，而垃圾回收器是内存回收的实践。
* 新生代
    * Serial
    * ParNew
    * Parallel Scavenge
* 年老代
    * CMS
    * Serial Old(MSC)
    * Parallel Old

###### Serial收集器
* 这是一个单线程收集器。意味着它只会使用一个CPU或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。
```
CPU0 =thread1=> |              | =thread1=> |              | =thread1=>
CPU1 =thread2=> | =GC thread=> | =thread2=> | =GC thread=> | =thread2=>
CPU2 =thread3=> | Young Gen    | =thread3=> | Old Gen      | =thread3=>
CPU3 =thread4=> |              | =thread4=> |              | =thread4=>
```

###### ParNew收集器
* 指多条垃圾收集线程并行工作，此时用户线程处于等待状态。
```
CPU0 =thread1=> | =GC thread=> | =thread1=> |              | =thread1=>
CPU1 =thread2=> | =GC thread=> | =thread2=> | =GC thread=> | =thread2=>
CPU2 =thread3=> | =GC thread=> | =thread3=> | Old Gen      | =thread3=>
CPU3 =thread4=> | Young Gen    | =thread4=> |              | =thread4=>
```
* 并行: Parallel
    * 指多条垃圾收集线程并行工作，此时用户线程处于等待状态
* 并发: Concurrent
    * 指用户线程和垃圾回收线程同时执行(不一定是并行，有可能是交叉执行)，用户进程在运行，而垃圾回收线程在另一个CPU上运行。

###### Parallel Scavenge收集器
* 这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。
* `CMS`等收集器的关注点是尽可能地缩短垃圾收集时用户线程所停顿的时间，而`Parallel Scavenge`收集器的目的是达到一个可控制的吞吐量
    * Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。
* 作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是GC的自适应调整策略(GC Ergonomics)。

###### Serial Old收集器
* 收集器的老年代版本，单线程，使用`标记-整理`。
```
CPU0 =thread1=> |              | =thread1=> |              | =thread1=>
CPU1 =thread2=> | =GC thread=> | =thread2=> | =GC thread=> | =thread2=>
CPU2 =thread3=> | Young Gen    | =thread3=> | Old Gen      | =thread3=>
CPU3 =thread4=> |              | =thread4=> |              | =thread4=>
```

###### Parallel Old收集器
* Parallel Old是 Parallel Scavenge收集器的老年代版本。多线程，使用`标记-整理`
```
CPU0 =thread1=> | =GC thread=> | =thread1=> | =GC thread=> | =thread1=>
CPU1 =thread2=> | =GC thread=> | =thread2=> | =GC thread=> | =thread2=>
CPU2 =thread3=> | =GC thread=> | =thread3=> | =GC thread=> | =thread3=>
CPU3 =thread4=> | =GC thread=> | =thread4=> | =GC thread=> | =thread4=>
```

###### CMS收集器
* CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。基于`标记-清除`算法实现。
* 运作步骤: 
    1. 初始标记(CMS initial mark): 标记`GC Roots`能直接关联到的对象
    2. 并发标记(CMS concurrent mark): 进行`GC Roots Tracing`
    3. 重新标记(CMS remark): 修正并发标记期间的变动部分
    4. 并发清除(CMS concurrent sweep)
```
CPU0 =thread1=> |                    | =thread1=> | =remarking=> | =======thread1=======> | =======thread1======>
CPU1 =thread2=> | =initial marking=> | =thread2=> | =remarking=> | =======thread2=======> | =======thread2======>
CPU2 =thread3=> |                    | =========> | =remarking=> | =concurrent sweeping=> | =reset=> | =========>
CPU3 =thread4=> |                    | =thread4=> | =remarking=> | =======thread4=======> | =======thread4======>
```    
* 缺点: 对CPU资源敏感、无法收集浮动垃圾、`标记-清除`算法带来的空间碎片。
   
###### G1收集器
* 面向服务端的垃圾回收器。
* 优点：并行与并发、分代收集、空间整合、可预测停顿。
* 运作步骤:
    * 初始标记(Initial Marking)
    * 并发标记(Concurrent Marking)
    * 最终标记(Final Marking)
    * 筛选回收(Live Data Counting and Evacuation)
```
CPU0 =thread1=> |                    | ======thread1=======> | =最终标记=> | =筛选回收=> | =thread1=>
CPU1 =thread2=> | =initial marking=> | ======thread2=======> | =最终标记=> | =筛选回收=> | =thread2=>
CPU2 =thread3=> |                    | =Concurrent Marking=> | =最终标记=> | =筛选回收=> | =thread3=>
CPU3 =thread4=> |                    | ======thread4=======> | =最终标记=> | =筛选回收=> | =thread4=>
```

##### 内存分配与回收策略
###### 对象优先在Eden分配
* 对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲区，将线程优先在(TLAB)上分配。少数情况会直接分配在老年代中。
* 堆的内存模型
```
+------+------+------+-----------+
| Eden | From |  To  |           |
| 8/10 | 1/10 | 1/10 |           |
+------+------+------+-----------+
|<-----1/3 Young---->|<-2/3 Old->|
```
* 新生代GC(Minor GC)
    * 发生在新生代的垃圾回收动作，频繁，速度快。
* 老年代GC(Major GC/Full GC)
    * 发生在老年代的垃圾回收动作，出现了Major GC经常会伴随至少一次Minor GC(非绝对)。Major GC的速度一般会比Minor GC慢十倍以上。

#### Java内存模型与线程
```
处理器 <-> 高速缓存 <-> |
处理器 <-> 高速缓存 <-> | <-> 主内存
处理器 <-> 高速缓存 <-> |
```

##### Java内存模型
```
Java线程 <-> 工作内存 <-> |
Java线程 <-> 工作内存 <-> | <-> 主内存
Java线程 <-> 工作内存 <-> |
```

###### 主内存和工作内存之间的交互
| 操作 | 作用对象 | 解释 |
| --- | --- | --- |
| `lock` | 主内存 | 把一个变量标识为一条线程独占的状态 |
| `unlock` | 主内存 | 把一个处于锁定状态的变量释放出来，释放后才可被其他线程锁定 |
| `read` | 主内存 | 把一个变量的值从主内存传输到线程工作内存中，以便`load`操作使用 |
| `load` | 工作内存 | 把`read`操作从主内存中得到的变量值放入工作内存中 |
| `use` | 工作内存 | 把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行这个操作 |
| `assign` | 工作内存 | 把一个从执行引擎接收到的值赋接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作 |
| `store` | 工作内存 | 把工作内存中的一个变量的值传送到主内存中，以便`write`操作 |
| `write` | 工作内存 | 把`store`操作从工作内存中得到的变量的值放入主内存的变量中 |

###### 对于volatile型变量的特殊规则
* 关键字`volatile`是Java虚拟机提供的最轻量级的同步机制。
* 一个变量被定义为`volatile`的特性:
    * 保证此变量对所有线程的可见性。但是操作并非原子操作，并发情况下不安全。
        * 如果不符合运算结果并不依赖变量当前值，或者能够确保只有单一的线程修改变量的值和变量不需要与其他的状态变量共同参与不变约束，就要通过加锁(使用`synchronize`或`java.util.concurrent`中的原子类)来保证原子性。
    * 禁止指令重排序优化。
        * 通过插入内存屏障保证一致性。

###### 对于long和double型变量的特殊规则
* Java要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于64位的数据类型，有一条宽松的规定: 允许虚拟机将没有被`volatile`修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的`load`、`store`、`read`和`write`这4个操作的原子性。这就是`long`和`double`的非原子性协定。

###### 原子性、可见性与有序性
* 原子性(Atomicity)
    * 原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。
    * 由 Java 内存模型来直接保证的原子性变量操作包括`read`、`load`、`assign`、`use`、`store`和`write`。大致可以认为基本数据类型的操作是原子性的。同时`lock`和`unlock`可以保证更大范围操作的原子性。而`synchronize`同步块操作的原子性是用更高层次的字节码指令`monitorenter`和`monitorexit`来隐式操作的。
* 可见性(Visibility)
    * 是指当一个线程修改了共享变量的值，其他线程也能够立即得知这个通知。
    * 主要操作细节就是修改值后将值同步至主内存(`volatile`值使用前都会从主内存刷新)，除了`volatile`还有`synchronize`和`final`可以保证可见性。同步块的可见性是由“对一个变量执行`unlock`操作之前，必须先把此变量同步会主内存中(`store`、`write`操作)”这条规则获得。而`final`可见性是指: 被`final`修饰的字段在构造器中一旦完成，并且构造器没有把"this"的引用传递出去(`this`引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见`final`字段的值。
* 有序性(Ordering)
    * 即程序执行的顺序按照代码的先后顺序执行。
    * 如果在被线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句指"线程内表现为串行的语义"，后半句是指"指令重排"现象和"工作内存与主内存同步延迟"现象。Java语言通过`volatile`和`synchronize`两个关键字来保证线程之间操作的有序性。`volatile`自身就禁止指令重排，而`synchronize`则是由“一个变量在同一时刻指允许一条线程对其进行`lock`操作”这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行的进入。

##### Java与线程
###### 线程的实现
* 使用内核线程实现
    * 直接由操作系统内核支持的线程，这种线程由内核完成切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口-轻量级进程(LWP)，轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都有一个内核级线程支持。
* 使用用户线程实现
    * 广义上来说，只要不是内核线程就可以认为是用户线程，因此可以认为轻量级进程也属于用户线程。狭义上说是完全建立在用户空间的线程库上的并且内核系统不可感知的。
* 使用用户线程夹加轻量级进程混合实现
* 平台不同实现方式不同，可以认为是一条Java线程映射到一条轻量级进程。

###### Java线程调度
* 协同式线程调度
    * 线程执行时间由线程自身控制，实现简单，切换线程自己可知，所以基本没有线程同步问题。坏处是执行时间不可控，容易阻塞。
* 抢占式线程调度
    * 每个线程由系统来分配执行时间。

###### 线程状态转换
* 五种状态:
    * 新建(new): 创建后尚未启动的线程。
    * 运行(Runable): `Runable`包括了操作系统线程状态中的`Running`和`Ready`，也就是出于此状态的线程有可能正在执行，也有可能正在等待CPU为他分配时间。
    * 无限期等待(Waiting): 出于这种状态的线程不会被CPU分配时间，它们要等其他线程显示的唤醒。
        * 以下方法会然线程进入无限期等待状态:
          * 没有设置Timeout参数的Object.wait()方法。
          * 没有设置Timeout参数的Thread.join()方法。
          * `LookSupport.park()`方法。
    * 限期等待(Timed Waiting): 处于这种状态的线程也不会分配时间，不过无需等待配其他线程显示地唤醒，在一定时间后他们会由系统自动唤醒。
        * 以下方法会让线程进入限期等待状态:
            * Thread.sleep() 方法。
            * 设置了 Timeout 参数的 Object.wait() 方法。
            * 设置了 Timeout 参数的 Thread.join() 方法。
            * LockSupport.parkNanos() 方法。
            * LockSupport.parkUntil() 方法。
    * 阻塞(Blocked):
        * 线程被阻塞了，“阻塞状态”和“等待状态”的区别是:
            * “阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；
            * “等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。
    * 结束(Terminated): 已终止线程的线程状态。
* 状态间转换:
    * `new` -`start()`-> `running`
    * `waiting` -`notify()/notifyAll()`-> `running`
    * `running` -`wait()`-> `waiting`
    * `running` <-`synchronized`-> `blocked`
    * `running` <-`sleep()`-> `timed waiting`
    * `running` -`run()结束`-> `Terminated`

#### 线程安全与锁优化
#### 类文件结构

#### 虚拟机类加载机制
* 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、装换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。
* 在Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。

##### 类加载时机
* 类的生命周期(7个阶段): 加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载
* 其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。
* 以下五种情况必须对类进行初始化(而加载、验证、准备自然需要在此之前完成):
    * 遇到`new`、`getstatic`、`putstatic`或`invokestatic`这 4 条字节码指令时没初始化触发初始化。使用场景：使用`new`关键字实例化对象、读取一个类的静态字段(被`final`修饰、已在编译期把结果放入常量池的静态字段除外)、调用一个类的静态方法。
    * 使用`java.lang.reflect`包的方法对类进行反射调用的时候。
    * 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需先触发其父类的初始化。
    * 当虚拟机启动时，用户需指定一个要加载的主类(包含`main()`方法的那个类)，虚拟机会先初始化这个主类。
    * 当使用`JDK 1.7`的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果`REF_getStatic`、`REF_putStati`、`REF_invokeStatic`的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需先触发其初始化。
* 前面的五种方式是对一个类的主动引用，除此之外，所有引用类的方法都不会触发初始化。

##### 类的加载过程
###### 加载
* 加载方式:
    * 通过一个类的全限定名来获取定义次类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。
    * 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    * 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法去这个类的各种数据的访问入口。
* 数组类的特殊性: 数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的
* 数组创建过程如下: 
    * 如果数组的组件类型是引用类型，那就递归采用类加载加载。
    * 如果数组的组件类型不是引用类型，Java虚拟机会把数组标记为引导类加载器关联。
    * 数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。
* 内存中实例的`java.lang.Class`对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。
* 加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。

###### 验证
* 是连接的第一步，确保`Class`文件的字节流中包含的信息符合当前虚拟机要求。
* 文件格式验证
    * 只有通过这个阶段的验证后，字节流才会进入内存的方法区进行存储，所以后面3个验证阶段全部是基于方法区的存储结构进行的，不再直接操作字节流。
* 元数据验证
    * 这一阶段主要是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。
* 字节码验证
    * 这是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法体进行校验分析，保证校验类的方法在运行时不会做出危害虚拟机安全的事件。
* 符号引用验证
    * 最后一个阶段的校验发生在迅疾将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，还有以上提及的内容。
    * 符号引用的目的是确保解析动作能正常执行，如果无法通过符号引用验证将抛出一个`java.lang.IncompatibleClass.ChangeError`异常的子类。如`java.lang.IllegalAccessError`、`java.lang.NoSuchFieldError`、`java.lang.NoSuchMethodError`等。

###### 准备
* 这个阶段正式为类分配内存并设置类变量初始值，内存在方法去中分配(含`static`修饰的变量不含实例变量)。
* ```public static int value = 1127;```
    * 这句代码在初始值设置之后为0，因为这时候尚未开始执行任何Java方法。而把`value`赋值为1127的`putstatic`指令是程序被编译后，存放于`clinit()`方法中，所以初始化阶段才会对`value`进行赋值。

###### 解析
* 这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
* 符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量。
* 直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和迅疾的内存布局实现有关。
* 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于常量池的7中常量类型。

###### 初始化
* 前面过程都是以虚拟机主导，而初始化阶段开始执行类中的Java代码。

##### 类加载器
* 通过一个类的全限定名来获取描述此类的二进制字节流。

###### 双亲委派模型
* 从Java虚拟机角度讲，只存在两种类加载器:
    * 一种是启动类加载器(C++实现，是虚拟机的一部分)
    * 另一种是其他所有类的加载器(Java实现，独立于虚拟机外部且全继承自`java.lang.ClassLoader`)

* 启动类加载器: 加载`lib`下或被`-Xbootclasspath`路径下的类
* 扩展类加载器: 加载`lib/ext`或者被`java.ext.dirs`系统变量所指定的路径下的类
* 应用程序类加载器`ClassLoader`负责，加载用户路径上所指定的类库。
* 启动类加载器 <- 扩展类加载器 <- 应用程序类加载器 <- 自定义类加载器
* 工作过程: 如果一个类加载器收到一个类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器。只有父类无法完成时子类才会尝试加载。

###### 破坏双亲委派模型
* keyword: 线程上下文加载器(Thread Context ClassLoader)



### 跨平台性
* 跨平台性是指java语言编写的程序，在一次编译后，可以在多个系统平台上运行。
* 实现原理: Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。



### 字节码
* Sun公司以及其他虚拟机提供商发布了许多可以运行在不同平台上的JVM虚拟机，而这些虚拟机都拥有一个共同的功能，那就是可以载入和执行同一种与平台无关的字节码(ByteCode)。
  于是，我们的源代码不再必须根据不同平台翻译成0和1，而是间接翻译成字节码，储存字节码的文件再交由运行于不同平台上的JVM虚拟机去读取执行，从而实现一次编写，到处运行的目的。
* `.java`文件在编译之后生成一个对应的`.class`，以文本的形式打开生成的`.class`文件会看见以`cafe babe`开头的16进制代码。
* 反编译字节码文件: 
    `javap [options] <classes>`
* 字节码文件信息
    * 开头的7行信息包括: `.Class文`件当前所在位置，最后修改时间，文件大小，MD5值，编译自哪个文件，类的全限定名，jdk次版本号，主版本号。
    * 然后紧接着的是该类的访问标志:

    | 标志名称 | 标志值 | 含义 |
    | --- | --- | --- |
    | `ACC_PUBLIC` | 0x0001 | 是否为Public类型 |
    | `ACC_FINAL` | 0x0010 | 是否被声明为final，只有类可以设置 |
    | `ACC_SUPER` | 0x0020 | 是否允许使用invokespecial字节码指令的新语义 |
    | `ACC_INTERFACE` | 0x0200 | 标志这是一个接口 |
    | `ACC_ABSTRACT` | 0x0400 | 是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假 |
    | `ACC_SYNTHETIC` | 0x1000 | 标志这个类并非由用户代码产生 |
    | `ACC_ANNOTATION` | 0x2000 | 标志这是一个注解 |
    
    * 常量池主要存放的是两大类常量: 字面量(Literal)和符号引用(Symbolic References)。字面量类似于java中的常量概念，如文本字符串，final常量等，而符号引用则属于编译原理方面的概念，包括以下三种:
        * 类和接口的全限定名(Fully Qualified Name)
        * 字段的名称和描述符号(Descriptor)
        * 方法的名称和描述符



### Java和C++的区别
* 都是面向对象的语言，都支持封装、继承和多态
* Java不提供指针来直接访问内存，程序内存更加安全
* Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。
* Java有自动内存管理机制，不需要程序员手动释放无用内存



### OracleJDK和OpenJDK的对比
* OracleJDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；
* OpenJDK是一个参考模型并且是完全开源的，而OracleJDK是OpenJDK的一个实现，并不是完全开源的；
* OracleJDK比OpenJDK更稳定。OpenJDK和OracleJDK的代码几乎相同，但OracleJDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择OracleJDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK可能会遇到了许多应用程序崩溃的问题，但是，只需切换到OracleJDK就可以解决问题；
* 在响应性和JVM性能方面，OracleJDK与OpenJDK相比提供了更好的性能；
* OracleJDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；
* OracleJDK根据二进制代码许可协议获得许可，而OpenJDK根据GPLv2许可获得许可。



## 基础语法
### 访问修饰符
#### private
* 被其修饰的属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。
* `当前类`

#### default
* 即不加任何访问修饰符，该模式下，只允许在同一个包中进行访问。
* `当前类` + `同一包`

#### public
* 被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包访问。
* `当前类` + `同一包` + `子类` + `其他包`

#### protected
* 介于public和private之间的一种访问修饰符，被其修饰的属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。
* `当前类` + `同一包` + `子类`



### 关键字
#### final有什么用
* 用于修饰类、属性和方法:
    * 被final修饰的类不可以被继承
    * 被final修饰的方法不可以被重写
    * 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的

#### this关键字
* this是自身的一个对象，代表对象本身，可以理解为: 指向对象本身的一个指针。
* this的用法在java中大体可以分为3种:
    * 普通的直接引用，this相当于是指向当前对象本身。
    * 形参与成员名字重名，用this来区分
        `this.name = name;`
    * 引用本类的构造函数
        `this();`
   
#### super关键字
* super可以理解为是指向自己超(父)类对象的一个指针，而这个超类指的是离自己最近的一个父类。
* super也有三种用法：
    * 普通的直接引用，与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。
    * 子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分。
        `super.name`
    * 引用父类构造函数
        `super();`

#### this与super的一些事
* 在构造方法中调用另一个构造方法，调用动作必须置于最起始的位置，放在构造方法的第一行。
* 不能在构造方法以外的任何方法内调用构造方法。
* 在一个构造方法内只能调用一个构造方法。
* 如果编写一个构造方法，既没有调用`super()`也没有调用`this()`，编译器会自动插入一个调用到父类构造方法中，而且不带参数。
* `super`不是一个对象的引用，不能将`super`赋值给另一个对象变量，它只是一个指示编译器调用父类方法的特殊关键字。

#### static关键字
* static的主要意义是在于创建独立于具体对象的域变量或者方法，以致于即使没有创建对象，也能使用属性和调用方法。
* 在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。
* 静态只能访问静态；非静态既可以访问非静态的，也可以访问静态的。
* static关键字使用场景:
    * 静态变量
        * 把一个变量声明为静态变量通常基于以下三个目的:
            * 作为共享变量使用
            * 减少对象的创建
            * 保留唯一副本
    * 静态方法
        * 将一个方法声明为静态方法，通常是为了方便在不创建对象的情况下调用。
    * 静态代码块
        * static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。
        * 静态代码块通常来说是为了对静态变量进行一些初始化操作，比如单例模式、定义枚举类
            ```java
            public class Singleton {
                private static Singleton instance;    
                static {
                    instance = new Singleton();
                }  
                private Singleton() {}
                public static Singleton getInstance() {
                    return instance;
                }
            }
            ```
    * 静态内部类
        * 静态内部类和非静态内部类的区别:
            * 非静态内部类对象持有外部类对象的引用(编译器会隐式地将外部类对象的引用作为内部类的构造器参数)；而静态内部类对象不会持有外部类对象的引用。
            * 由于非静态内部类的实例创建需要有外部类对象的引用，所以非静态内部类对象的创建必须依托于外部类的实例；而静态内部类的实例创建只需依托外部类。
            * 并且由于非静态内部类对象持有了外部类对象的引用，因此非静态内部类可以访问外部类的非静态成员；而静态内部类只能访问外部类的静态成员；
        * 两者的根本性区别其实也决定了用static去修饰内部类的真正意图:
            * 内部类需要脱离外部类对象来创建实例
            * 避免内部类使用过程中出现内存溢出
    * 静态导入
        * 静态导入其实就是`import static`，用来导入某个类或者某个包中的静态方法或者静态变量。
* static变量和普通成员变量区别
    * 所属不同。static变量属于类，不单属于任何对象；普通成员变量属于某个对象。
    * 存储区域不同。static变量位于方法区；普通成员变量位于堆区。
    * 生命周期不同。static变量生命周期与类的生命周期相同；普通成员变量和其所属的对象的生命周期相同。
    * 在对象序列化时(Serializable)，static变量会被排除在外(因为static变量是属于类的，不属于对象)。

#### new关键字
* new创建对象实例(对象实例在堆内存中)，对象引用指向对象实例(对象引用存放在栈内存中)。
* 一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）



### 面向对象
#### 三大特性
* 封装
    * 指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节，但可以通过该对象对外的提供的接口来访问该对象。
    * 使用封装有三大好处：
        * 良好的封装能够减少耦合。
        * 类内部的结构可以自由修改。
        * 可以对成员进行更精确的控制。
        * 隐藏信息，实现细节。
* 继承
    * 继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。
    * 继承所描述的是`is-a`的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。
    * 同时在继承关系中，继承者完全可以替换被继承者，反之则不可以，例如我们可以说猫是动物，但不能说动物是猫就是这个道理，其实对于这个我们将其称之为“向上转型”。
    * 三个特点:
        * 子类拥有父类非private的属性和方法。
        * 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
        * 子类可以用自己的方式实现父类的方法。
    * 构造器
        * 对于构造器而言，它只能够被调用，而不能被继承。调用父类的构造方法我们使用`super()`即可。
        * 编译器会默认给子类调用父类的构造器，也就是从父类开始向子类一级一级地完成构建。
        * 默认调用父类的构造器是有前提的: 父类有默认构造器。如果父类没有默认构造器，我们就要必须显式的使用`super()`来调用父类构造器，否则编译器会报错: 无法找到符合父类形式的构造器。
        * 对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点: 在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。
        * 对于继承而言，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。
    * 向上转型
        * 在上面的继承中我们谈到继承是`is-a`的相互关系，猫继承与动物，所以我们可以说猫是动物，或者说猫是动物的一种。
        * 将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。这就是为什么编译器在“未曾明确表示转型”活“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。
    * 继承存在如下缺陷:
        * 父类变，子类就必须变。
        * 继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。
        * 继承是一种强耦合关系
* 多态
    * 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。
    * 指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法(动态连接、动态调用)。
    * 对于面向对象而言，多态分为编译时多态和运行时多态:
        * 其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。
        * 而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。
    * 子类Child继承父类Father，我们可以编写一个指向子类的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态性就是相同的消息使得不同的类做出不同的响应。
    * 多态的实现机制遵循一个原则: 当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。
    * 有两种形式可以实现多态: 
        * 基于继承实现的多态
            * 基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。
            * 基于继承实现的多态可以总结如下：对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。
            * 如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。
        * 基于接口实现的多态
            * 继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。
            * 在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。
            * 继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。


#### 五大原则
* 单一职责原则
    * 一个类，最好只做一件事，只有一个引起它的变化。
* 开放封闭原则
    * 软件实体应该是可扩展的，而不可修改的。
    * 一个类，可以扩展(添加属性和功能)，但是不要修改已经写好的属性和方法。
* 里氏替换原则
    * 子类必须能够替换其基类。
* 依赖倒置原则
    * 依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。
* 接口隔离原则
    * 使用多个小的专门的接口，而不要使用一个大的总接口。
    * 目的:
        * 避免引用接口的类，需要实现其实用不到的接口方法、属性。
        * 避免当接口修改的时候，有一连串的实现类需要更改。
    * 分离的手段主要有以下两种:
        * 委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。
        * 多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。
    * 委托分离，不直接使用原先的接口，可以用另外增加一个新的接口或类来实现需求。
    * 多重继承分离，JDK源码、Spring框架使用了这种方式，后续的JDK源码解析系列会提及，好奇的朋友可以查看集合类的结构。

### 类与接口
#### 抽象类和接口的对比
* 抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。
* 从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。
* 相同点  
    * 接口和抽象类都不能实例化
    * 都位于继承的顶端，用于被其他实现或继承
    * 都包含抽象方法，其子类都必须覆写这些抽象方法
* 不同点

| 参数 | 抽象类 | 接口 |
| --- | --- | --- |
| 声明 | 抽象类使用abstract关键字声明 | 接口使用interface关键字声明 |
| 实现 | 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现 | 子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现 |
| 构造器 | 抽象类可以有构造器 | 接口不能有构造器 |
| 访问修饰符 | 抽象类中的方法可以是任意访问修饰符 | 接口方法默认修饰符是public。并且不允许定义为 private 或者 protected |
| 多继承 | 一个类最多只能继承一个抽象类 | 一个类可以实现多个接口 |
| 字段声明 | 抽象类的字段声明可以是任意的 | 接口的字段默认都是 static 和 final 的 |

* Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。
* 在接口和抽象类的选择上，必须遵守这样一个原则:
    * 行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。
    * 选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。

#### 普通类和抽象类
* 普通类不能包含抽象方法，抽象类可以包含抽象方法。
* 抽象类不能直接实例化，普通类可以直接实例化。
* 抽象方法必须为public或者protected，缺省情况下默认为public。
* 抽象类不能使用final修饰


### 变量与方法
* 变量: 在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域
* 成员变量: 方法外部，类内部定义的变量
* 局部变量：类的方法中的变量。
* 成员变量和局部变量的区别:
    * 作用域
        * 成员变量: 针对整个类有效。
        * 局部变量: 只在某个范围内有效。(一般指的就是方法,语句体内)
    * 存储位置
        * 成员变量: 随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。
        * 局部变量: 在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。
    * 生命周期
        * 成员变量: 随着对象的创建而存在，随着对象的消失而消失
        * 局部变量: 当方法调用完，或者语句结束后，就自动释放。
    * 初始值
        * 成员变量: 有默认初始值。
        * 局部变量: 没有默认初始值，使用前必须赋值。
* 使用原则
    * 在使用变量时需要遵循的原则为: 就近原则
    * 首先在局部范围找，有就使用；接着在成员位置找。
* 静态变量和实例变量区别
    * 静态变量: 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。
    * 实例变量: 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。
* 静态变量与普通变量区别
    * static变量也称作静态变量，静态变量和非静态变量的区别是: 
        * 静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。
        * 而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。
    * 还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。
* 静态方法和实例方法区别
    * 静态方法和实例方法的区别主要体现在两个方面：
        * 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。
        * 静态方法在访问本类的成员时，只允许访问静态成员(即静态成员变量和静态方法)，而不允许访问实例成员变量和实例方法；实例方法则无此限制
    * 由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。


### 构造方法
* 构造方法的作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。
* Java程序在执行子类的构造方法之前，如果没有用`super()`来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用`super()`来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。
* 构造方法特性:
    * 名字与类名相同。
    * 没有返回值，但不能用void声明构造函数。
    * 生成类的对象时自动执行，无需调用。



### 内部类
#### 内部类基础
##### 成员内部类
* Member Inner Class
* 成员内部类是最普通的内部类，它的定义为位于另一个类的内部。
    ```java
    class Circle {
        private double radius = 0;
        public static int count =1;
        public Circle(double radius) {
            this.radius = radius;
            getDrawInstance().drawSahpe();
        } 
        private Draw getDrawInstance() {
            return new Draw();
        }
        class Draw {
            public void drawSahpe() {
                System.out.println(radius);
                System.out.println(count);
            }
        }
    }
    ```
    * 类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法，包括private成员和静态成员。
    * 当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问:
        * 外部类.this.成员变量
        * 外部类.this.成员方法
    * 在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问
* 成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。
    ```java
    public class Test {
        public static void main(String[] args)  {
            //第一种方式：
            Outter outter = new Outter();
            Outter.Inner inner = outter.new Inner();  //必须通过Outter对象来创建
             
            //第二种方式：
            Outter.Inner inner1 = outter.getInnerInstance();
        }
    }
     
    class Outter {
        private Inner inner = null;
        public Outter() {}
        public Inner getInnerInstance() {
            if(inner == null)
                inner = new Inner();
            return inner;
        }
        class Inner {
            public Inner() {
                 
            }
        }
    }
    ```
    * 内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。

##### 局部内部类
* Local Inner Class
* 局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。
    ```java
    class People{
        public People() {
             
        }
    }
     
    class Man{
        public Man(){
             
        }
        public People getWoman(){
            class Woman extends People{
                int age =0;
            }
            return new Woman();
        }
    }
    ```
    * 局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。

##### 匿名内部类
* Anonymous Inner Class
* 匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。
* 下面这段代码是一段Android事件监听代码:
    ```java
    scan_bt.setOnClickListener(new OnClickListener() {
        @Override
        public void onClick(View v) {
            // TODO Auto-generated method stub
        }
    });
    
    history_bt.setOnClickListener(new OnClickListener() {
        @Override
        public void onClick(View v) {
            // TODO Auto-generated method stub
        }
    });
    ```
* 代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。
* 当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。
    ```java
    private void setListener() {
        scan_bt.setOnClickListener(new Listener1());       
        history_bt.setOnClickListener(new Listener2());
    }
     
    class Listener1 implements View.OnClickListener{
        @Override
        public void onClick(View v) {
            // TODO Auto-generated method stub       
        }
    }
     
    class Listener2 implements View.OnClickListener{
        @Override
        public void onClick(View v) {
            // TODO Auto-generated method stub        
        }
    }
    ```
    * 这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。
* 匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为`Outter$1.class`。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。

##### 静态内部类
* Static inner classes
* 静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。
    ```java
    public class Test {
        public static void main(String[] args)  {
            Outter.Inner inner = new Outter.Inner();
        }
    }
     
    class Outter {
        int a = 10;
        static int b = 5;
        public Outter() {}
        static class Inner {
            public Inner() {
                System.out.println(a); // 报错
                System.out.println(b); 
            }
        }
    }
    ```

#### 深入理解内部类
* 编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件，下面是`Outter.java`的代码:
    ```java
    public class Outter {
        private Inner inner = null;
        public Outter() {}
        public Inner getInnerInstance() {
            if(inner == null)
                inner = new Inner();
            return inner;
        }
        protected class Inner {
            public Inner() {}
        }
    }
    ```
    * 编译之后生成两个字节码文件:
        * `Outter$Inner.class`
        * `Outter.class`
* 编译器会默认为成员内部类添加了一个指向外部类对象的引用
* 虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的`Outter this&0`指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。
* 从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对`Outter this&0`引用进行初始化赋值，也就无法创建成员内部类的对象了。
* 静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。另外，静态内部类是不持有指向外部类对象的引用的，这个读者可以自己尝试反编译class文件看一下就知道了，是没有`Outter this&0`引用的。
* 局部内部类和匿名内部类访问局部变量的时候必须要加上final。因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。
* 内部类的优点
    * 一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！
    * 内部类不为同一包的其他类所见，具有很好的封装性；
    * 内部类有效实现了“多重继承”，优化 java 单继承的缺陷。
    * 匿名内部类可以很方便的定义回调。
* 内部类有哪些应用场景
    * 一些多算法场合
    * 解决一些非面向对象的语句块。
    * 适当使用内部类，使得代码更加灵活和富有扩展性。
    * 当某个类除了它的外部类，不再被其他的类使用时。



### 重写与重载
* 重载: 发生在同一个类中，方法名相同参数列表不同(参数类型不同、个数不同、顺序不同)，与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分
* 重写: 发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类(里氏代换原则)；如果父类方法访问修饰符为private则子类中就不是重写。
* 造器不能被继承，因此不能被重写，但可以被重载。
* 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。



### 对象相等判断
#### ==和equals
* `==`: 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)
* `equals()`: 它的作用也是判断两个对象是否相等。但它一般有两种使用情况:
    * 类没有覆盖`equals()`方法。则通过`equals()`比较该类的两个对象时，等价于通过`==`比较这两个对象。
    * 类覆盖了`equals()`方法。一般，我们都覆盖`equals()`方法来两个对象的内容相等；若它们的内容相等，则返回true(即认为这两个对象相等)。
* String中的equals方法是被重写过的，因为object的`equals`方法是比较的对象的内存地址，而String的`equals`方法比较的是对象的值。
* 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。

#### hashCode和equals
* `hashCode()`: 作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()` 定义在JDK的`Object.java`中，这就意味着Java中的任何类都包含有`hashCode()`函数。
* 如果两个对象相等，则hashcode一定也是相同的
* 两个对象相等，对两个对象分别调用equals方法都返回true
* 两个对象有相同的hashcode值，它们也不一定是相等的